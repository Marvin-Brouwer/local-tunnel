/* eslint-disable consistent-return, no-underscore-dangle */

import { parse } from 'node:url';
import { EventEmitter } from 'node:events';
// TODO replace with fetch
import axios from 'axios';
import { TunnelCluster } from './tunnel-cluster.ts.reference';
import debug from 'debug'
import { TunnelConfig } from '../client/client-config';

const clientDebug = debug('localtunnel:client');

type TODO = any;

export class Tunnel extends EventEmitter {

  #config: TunnelConfig;
  #tunnelCluster: TunnelCluster;
  #closed: boolean;
  #clientId: TODO;
  #url: TODO;
  #cachedUrl: TODO;

  public get closed(): boolean {
    return this.#closed
  }
  public get url(): URL {
    return new URL(this.#url);
  }

  constructor(config: TunnelConfig) {
    super({ captureRejections: true });
    this.#config = config;
    this.#closed = false;
  }

  #getInfo(body: TODO): TODO {
    const { id, ip, port: remote_port, url, cached_url, max_conn_count } = body;
    const { server: { hostName }, port: local_port, hostName: local_host, https } = this.#config;
    const { skipCertificateValidation, cert } = https ?? { };
    return {
      name: id,
      url,
      cached_url,
      max_conn: max_conn_count || 1,
      remote_host: `https://${hostName}`,
      remote_ip: ip,
      remote_port,
      local_port,
      local_host,
      local_https: !!https,
      local_cert: cert?.pemLocation,
      local_key: cert?.keyLocation,
      local_ca: cert?.certificateAuthorityLocation,
      allow_invalid_cert: !!skipCertificateValidation,
    };
  }

  // initialize connection
  // callback with connection info
  #init(cb: TODO): void {
    const getInfo = this.#getInfo.bind(this);

    // no subdomain at first, maybe use requested domain
    const { subDomain } = this.#config.server ;
    const assignedDomain = subDomain.constructor === Symbol
      ? subDomain.description
      : subDomain as string
    // where to quest
    const uri = `${this.#config.hostName}/${assignedDomain}`;

    (function getUrl() {
      axios
        .get(uri, {
          responseType: 'json',
        })
        .then(res => {
          const body = res.data;
          clientDebug('got tunnel information', res.data);
          if (res.status !== 200) {
            const err = new Error(
              (body && body.message) || 'localtunnel server returned an error, please try again'
            );
            return cb(err);
          }
          cb(null, getInfo(body));
        })
        .catch(err => {
          clientDebug(`tunnel server offline: ${err.message}, retry 1s`);
          return setTimeout(getUrl, 1000);
        });
    })();
  }

  #establish(info: TODO): TODO {
    // increase max event listeners so that localtunnel consumers don't get
    // warning messages as soon as they setup even one listener. See #71
    this.setMaxListeners(info.max_conn + (EventEmitter.defaultMaxListeners || 10));

    this.#tunnelCluster = new TunnelCluster(info);

    // only emit the url the first time
    this.#tunnelCluster.once('open', () => {
      this.emit('url', info.url);
    });

    // re-emit socket error
    this.#tunnelCluster.on('error', err => {
      clientDebug('got socket error', err.message);
      this.emit('error', err);
    });

    let tunnelCount = 0;

    // track open count
    this.#tunnelCluster.on('open', tunnel => {
      tunnelCount++;
      clientDebug('tunnel open [total: %d]', tunnelCount);

      const closeHandler = () => {
        tunnel.destroy();
      };

      if (this.closed) {
        return closeHandler();
      }

      this.once('close', closeHandler);
      tunnel.once('close', () => {
        this.removeListener('close', closeHandler);
      });
    });

    // when a tunnel dies, open a new one
    this.#tunnelCluster.on('dead', () => {
      tunnelCount--;
      clientDebug('tunnel dead [total: %d]', tunnelCount);
      if (this.closed) {
        return;
      }
      this.#tunnelCluster.open();
    });

    this.#tunnelCluster.on('request', req => {
      this.emit('request', req);
    });

    // establish as many tunnels as allowed
    for (let count = 0; count < info.max_conn; ++count) {
      this.#tunnelCluster.open();
    }
  }

  open(cb: TODO): void {
    this.#init((err, info) => {
      if (err) {
        return cb(err);
      }

      this.#clientId = info.name;
      this.#url = info.url;

      // `cached_url` is only returned by proxy servers that support resource caching.
      if (info.cached_url) {
        this.#cachedUrl = info.cached_url;
      }

      this.#establish(info);
      cb();
    });
  }

  close() {
    this.#closed = true;
    this.emit('close');
  }
};
